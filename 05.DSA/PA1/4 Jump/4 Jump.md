# 1.4 Jump report

2018011365 张鹤潇 计84

#### 算法简述

动态规划。到达第j个点的花费是$f(j)=min\{f[i]+t[i]\}$，其中$l[i]\le j \le r[i]$.

考虑到$l[i],r[i]$的单调性，用单调队列对dp进行优化。

维护`input`和`dp`两个队列，在读入第$i$个数据时，将`input`队列中所有$l\le i$的元素取出，加入`dp`队列中，并将`dp`队列中所有满足$r<i$的元素出队。此时，如果`dp`不为空，则表明$i$号格子是可以到达的；将读入的$t$与`dp`中的最小$t$值相加，加入到`input`队列中。

#### 问题及其解决

一开始没有想到会出现某些格子无法被到达的情况，获得了许多次5分的好成绩。

#### 复杂度分析

维护两个队列，空间复杂度$O(n)$；

如前所述，只要从1到n一遍循环即可，时间复杂度严格$O(n)$.

#### 补充

由于一开始一直WA，我还想了另外一种解法：

维护一个小顶堆和栈。在读入第$i(i>1)$个数据时，取出堆顶元素，如果其不满足$l\le j \le r$，则将其取出，加入辅助栈中。重复以上操作，如果能取到满足条件的元素，表明$i$号格子是可以到达的，将读入的$t$与`dp`中的最小$t$值相加，加入堆中；如果取不到(堆空)，表示$i$是不可到达的。最后再将辅助栈中的元素填回堆中。

显然，与上述算法相比，优先队列的解法更直观，效率也更高。