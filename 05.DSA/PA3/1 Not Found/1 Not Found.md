# PA3-1 Not Found Report

#### 算法简述

考虑到长度为$n$的01串A有$n-k$个长度为$k$的子串，而长度为$k$的01串共有$2^k$种。根据鸽巢原理，令$2^k\ge n-k$，可知在长为$O(log_2 n)$的01串中会出现A的非子串。

由此，从1开始向上枚举子串长度k；对任一k，枚举长度为k的子串，再按字典序枚举长度为k的所有01串，如果发现某一01串在A的子串中没有出现过，就找到了本题的答案。

#### 困难及其解决

本题空间限制严格，所有数据都需要压位存储。我参考课上讲过的bitmap原理，用位运算完成了输入、输出、子串枚举和记录的功能。

如果枚举长度为k的所有子串，会无法满足时间限制。我用全局变量`cnt`记录当前已枚举的子串种类，如果$cnt= 2^k$，就说明所有长度为k的01串都是A的子串，直接进行下一个长度的枚举。

#### 复杂度分析

记$n=length(A)$.

按位存储数据，空间复杂度$O(n/8)=O(n)$.

最坏情况下，枚举子串的时间复杂度$O(n\log{n})$，枚举01串的时间复杂度$O(\sum _{i=1}^{\log_2{n}}2^i)=O(n)$，总时间复杂度$O(n\log n)$.