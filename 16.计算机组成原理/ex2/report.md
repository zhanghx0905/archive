# 实验报告：运算器 ALU 实验，熟悉 Vivado 环境

2018011365 张鹤潇

## 实验目的

+ 熟悉硬件描述语言；
+ 熟悉开发环境 Vivado，了解硬件系统开发的基本过程；
+ 掌握ALU基本设计方法和简单运算器的数据传送通路；验证ALU的功能。

## 实验任务

使用 Verilog 语言和开发工具 Vivado，实现 ALU，支持包括 ADD，SUB，AND，OR，XOR 等在内的十种运算；并实现一个状态机，根据状态机状态的变化来输入操作数及操作码，输出运算结果和标志位。

## 实验过程

以网络学堂下发的模板代码为基础，补充相关功能。

ALU 模块需要根据操作码对输入执行各种运算，大部分运算直接调用 Verilog 的操作符即可，`SRL` 和 `ROL` 手动实现如下，

```verilog
// tmp32 is 32-bit reg, tmp 16 is 16-bit reg
Sra:begin
	tmp16 = (a[15] == 0) ? 16'b0 : 16'hffff;
    tmp32 = {tmp16, a} >> b;
    result = tmp32[15:0];
end
Rol:begin
	tmp32 = {a, a} << b;
    result = tmp32[31:16];
end
```

对于加减操作，需要检查是否发生溢出。

在云平台上测试如下，

| 操作码   | 操作数 A | 操作数 B | 运算结果 | 标志位 |
| -------- | -------- | -------- | -------- | ------ |
| ADD (1)  | 0x8000   | 0x8000   | 0x0000   | 1      |
| SUB (2)  | 0x0851   | 0x0519   | 0x0338   | 0      |
| AND (3)  | 0x0519   | 0x0851   | 0x0011   | 0      |
| OR (4)   | 0x0519   | 0x0851   | 0xed59   | 0      |
| XOR (5)  | 0x0519   | 0x0851   | 0x0d48   | 0      |
| NOT (6)  | 0xd083   | -        | 0x2f7c   | 0      |
| SLL (7)  | 0x0519   | 0x0004   | 0x5190   | 0      |
| SRL (8)  | 0x0519   | 0x0004   | 0x0051   | 0      |
| SRA (9)  | 0x8a19   | 0x0006   | 0xfe28   | 0      |
| ROL (10) | 0x67f6   | 0x000b   | 0xb33f   | 0      |

所有实验结果均与预期一致。

## 思考题

1. **ALU 进行算术逻辑运算所使用的电路是组合逻辑电路还是时序逻辑电路？**

   ALU 进行运算的电路是组合逻辑电路，不涉及时序。

2. **如果给定了 A 和 B 的初值，且每次运算完后结果都写入到 B 中，再进行下次运算。这样一个带暂存功能的 ALU 要增加一些什么电路来实现？**

   应当给 A, B 的输入寄存器赋初值，并增加数据选择器，从而在 B 的储存值和输入值之间选择。

## 总结反思

本次实验的流程没有第一次实验那么复杂，但要特别注意硬件编程中的异步行为 —— 同一个输入触发的多个 `always` 块，其执行顺序是不确定的。在编程中应以此为准则组织逻辑。

比如对标志位的赋值，应在状态机到达 S2 时就进行，不能等到 S3 才执行。因为状态切换到 S3 时，LED 的显示内容也发生改变，这种改变与S3状态下标志位赋值的先后顺序是不确定的。


